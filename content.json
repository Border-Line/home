{"meta":{"title":"River Z","subtitle":"Eat something that never eaten before.","description":"Hello, I'm River Z. A front-end developer. Like to play games, favorite game is Witcher 3, and the upcoming CyberPunk 2077. Want to eat something that never eaten before.","author":"River Z","url":"https://laputaz.github.io/home","root":"/"},"pages":[{"title":"","date":"2019-10-26T02:42:39.000Z","updated":"2021-06-14T08:28:52.079Z","comments":true,"path":"categories/index.html","permalink":"https://laputaz.github.io/home/categories/index.html","excerpt":"","text":""},{"title":"Жди меня, и я вернусь","date":"2021-06-14T08:28:52.079Z","updated":"2021-06-14T08:28:52.079Z","comments":true,"path":"about/index.html","permalink":"https://laputaz.github.io/home/about/index.html","excerpt":"","text":"一切, 为了生活 Константин Симонов Жди меня, и я вернусь.Только очень жди,Жди, когда наводят грустьЖелтые дожди,Жди, когда снега метут,Жди, когда жара,Жди, когда других не ждут,Позабыв вчера.Жди, когда из дальних местПисем не придет,Жди, когда уж надоестВсем, кто вместе ждет. Жди меня, и я вернусь,Не желай добраВсем, кто знает наизусть,Что забыть пора.Пусть поверят сын и матьВ то, что нет меня,Пусть друзья устанут ждать,Сядут у огня,Выпьют горькое виноНа помин души…Жди. И с ними заодноВыпить не спеши. Жди меня, и я вернусь,Всем смертям назло.Кто не ждал меня, тот пустьСкажет: — Повезло.Не понять, не ждавшим им,Как среди огняОжиданием своимТы спасла меня.Как я выжил, будем знатьТолько мы с тобой,-Просто ты умела ждать,Как никто другой."},{"title":"","date":"2019-10-26T02:38:56.000Z","updated":"2021-06-14T08:28:52.080Z","comments":true,"path":"tags/index.html","permalink":"https://laputaz.github.io/home/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Web Components","slug":"Web-Components","date":"2021-02-12T12:14:10.000Z","updated":"2021-06-14T08:28:52.078Z","comments":true,"path":"2021/02/12/Web-Components/","link":"","permalink":"https://laputaz.github.io/home/2021/02/12/Web-Components/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ios下input聚焦问题","slug":"ios下input聚焦问题","date":"2021-02-12T05:19:33.000Z","updated":"2021-06-14T08:28:52.079Z","comments":true,"path":"2021/02/12/ios下input聚焦问题/","link":"","permalink":"https://laputaz.github.io/home/2021/02/12/ios%E4%B8%8Binput%E8%81%9A%E7%84%A6%E9%97%AE%E9%A2%98/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"docker容器化","slug":"docker容器化","date":"2021-02-10T12:55:27.000Z","updated":"2021-06-14T08:28:52.074Z","comments":true,"path":"2021/02/10/docker容器化/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/docker%E5%AE%B9%E5%99%A8%E5%8C%96/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"基于vue-cli实现自己的cli","slug":"基于vue-cli实现自己的cli","date":"2021-02-10T10:07:53.000Z","updated":"2021-06-14T08:28:52.077Z","comments":true,"path":"2021/02/10/基于vue-cli实现自己的cli/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E5%9F%BA%E4%BA%8Evue-cli%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84cli/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"基于百度amis的lowcode方案","slug":"基于百度amis的lowcode方案","date":"2021-02-10T10:00:20.000Z","updated":"2021-06-14T08:28:52.077Z","comments":true,"path":"2021/02/10/基于百度amis的lowcode方案/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6amis%E7%9A%84lowcode%E6%96%B9%E6%A1%88/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"组件库的封装以及集成storybook展示","slug":"组件库的封装以及集成storybook展示","date":"2021-02-10T09:57:08.000Z","updated":"2021-06-14T08:28:52.078Z","comments":true,"path":"2021/02/10/组件库的封装以及集成storybook展示/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%9B%86%E6%88%90storybook%E5%B1%95%E7%A4%BA/","excerpt":"","text":"background admin 的工程越来越庞大, 包含了各个团队的模块, 包括库存/活动上线/市场运营/订单管理/财务/会员管理/积分管理/产品工具(如AB testing 实验)等等, 往往是由各个团队自行维护, 代码风格不尽相同, 互相之间较为独立, 很容易因为不熟悉导致同一个功能的重复开发, 所以其中一个优化点就是组件的抽离 组件库组件抽离, 结合 storybook, 让组件状态可视化, 便于组件管理和复用, 同时也方便设计的同事参考 建立 admin 组件库 建立 admin storybook - 可独立运行, 也可暴露文档至 klook-story展示","categories":[],"tags":[]},{"title":"上传文件到 aws s3 实现","slug":"上传文件到-aws-s3-实现","date":"2021-02-10T09:52:38.000Z","updated":"2021-06-14T08:28:52.075Z","comments":true,"path":"2021/02/10/上传文件到-aws-s3-实现/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0-aws-s3-%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"storybook 多语言插件实现(react)","slug":"storybook-多语言插件实现-react","date":"2021-02-10T09:52:19.000Z","updated":"2021-06-14T08:28:52.074Z","comments":true,"path":"2021/02/10/storybook-多语言插件实现-react/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/storybook-%E5%A4%9A%E8%AF%AD%E8%A8%80%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0-react/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"elementui的表格summary自定义","slug":"elementui的表格summary自定义","date":"2021-02-10T09:52:02.000Z","updated":"2021-06-14T08:28:52.074Z","comments":true,"path":"2021/02/10/elementui的表格summary自定义/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/elementui%E7%9A%84%E8%A1%A8%E6%A0%BCsummary%E8%87%AA%E5%AE%9A%E4%B9%89/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"基于elementui的表格&表单&弹窗组件封装实践","slug":"基于elementui的表格-表单-弹窗组件封装实践","date":"2021-02-10T09:51:11.000Z","updated":"2021-06-14T08:28:52.076Z","comments":true,"path":"2021/02/10/基于elementui的表格-表单-弹窗组件封装实践/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E5%9F%BA%E4%BA%8Eelementui%E7%9A%84%E8%A1%A8%E6%A0%BC-%E8%A1%A8%E5%8D%95-%E5%BC%B9%E7%AA%97%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"google ads 和 sem 相关知识","slug":"google-ads-和-sem-相关知识","date":"2021-02-10T09:50:18.000Z","updated":"2021-06-14T08:28:52.074Z","comments":true,"path":"2021/02/10/google-ads-和-sem-相关知识/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/google-ads-%E5%92%8C-sem-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"cropperjs + canvas 实现图片标记工具","slug":"cropperjs-canvas-实现图片标记工具","date":"2021-02-10T09:49:16.000Z","updated":"2021-06-14T08:28:52.073Z","comments":true,"path":"2021/02/10/cropperjs-canvas-实现图片标记工具/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/cropperjs-canvas-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%A0%87%E8%AE%B0%E5%B7%A5%E5%85%B7/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"cloudinary和编写基于cloudinary的上传插件","slug":"cloudinary和编写基于cloudinary的上传插件","date":"2021-02-10T09:48:18.000Z","updated":"2021-06-14T08:28:52.073Z","comments":true,"path":"2021/02/10/cloudinary和编写基于cloudinary的上传插件/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/cloudinary%E5%92%8C%E7%BC%96%E5%86%99%E5%9F%BA%E4%BA%8Ecloudinary%E7%9A%84%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"使用自定义 loader 按需加载element的css","slug":"使用自定义-loader-按需加载element的css","date":"2021-02-10T09:47:05.000Z","updated":"2021-06-14T08:28:52.076Z","comments":true,"path":"2021/02/10/使用自定义-loader-按需加载element的css/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89-loader-%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BDelement%E7%9A%84css/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Grid布局: 跑偏的用途","slug":"Grid布局-跑偏的用途","date":"2021-02-10T09:44:43.000Z","updated":"2021-06-14T08:28:52.073Z","comments":true,"path":"2021/02/10/Grid布局-跑偏的用途/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/Grid%E5%B8%83%E5%B1%80-%E8%B7%91%E5%81%8F%E7%9A%84%E7%94%A8%E9%80%94/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"二进制到blob和arraybuffer(四): wbmp图片格式转换","slug":"二进制到blob和arraybuffer-四-wbmp图片格式转换","date":"2021-02-10T09:43:17.000Z","updated":"2021-06-14T08:28:52.076Z","comments":true,"path":"2021/02/10/二进制到blob和arraybuffer-四-wbmp图片格式转换/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%B0blob%E5%92%8Carraybuffer-%E5%9B%9B-wbmp%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"二进制到blob和arraybuffer(三): js中的blob和arraybuffer","slug":"二进制到blob和arraybuffer-三-js中的blob和arraybuffer","date":"2021-02-10T09:42:47.000Z","updated":"2021-06-14T08:28:52.075Z","comments":true,"path":"2021/02/10/二进制到blob和arraybuffer-三-js中的blob和arraybuffer/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%B0blob%E5%92%8Carraybuffer-%E4%B8%89-js%E4%B8%AD%E7%9A%84blob%E5%92%8Carraybuffer/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"二进制到blob和arraybuffer(二): js进制转换","slug":"二进制到blob和arraybuffer-二-js进制转换","date":"2021-02-10T09:40:26.000Z","updated":"2021-06-14T08:28:52.075Z","comments":true,"path":"2021/02/10/二进制到blob和arraybuffer-二-js进制转换/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%B0blob%E5%92%8Carraybuffer-%E4%BA%8C-js%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"二进制到blob和arraybuffer(一): 二进制回顾","slug":"二进制到blob和arraybuffer-一-二进制回顾","date":"2021-02-10T09:40:01.000Z","updated":"2021-06-14T08:28:52.075Z","comments":true,"path":"2021/02/10/二进制到blob和arraybuffer-一-二进制回顾/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%B0blob%E5%92%8Carraybuffer-%E4%B8%80-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9B%9E%E9%A1%BE/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"色值转换之 rgb / hex / hsl","slug":"色值转换之-rgb-hex-hsl","date":"2021-02-10T09:30:32.000Z","updated":"2021-06-14T08:28:52.078Z","comments":true,"path":"2021/02/10/色值转换之-rgb-hex-hsl/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E8%89%B2%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B9%8B-rgb-hex-hsl/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"使用lerna管理npm包","slug":"使用lerna管理npm包","date":"2021-02-10T09:23:56.000Z","updated":"2021-06-14T08:28:52.076Z","comments":true,"path":"2021/02/10/使用lerna管理npm包/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E4%BD%BF%E7%94%A8lerna%E7%AE%A1%E7%90%86npm%E5%8C%85/","excerpt":"","text":"lerna工程最近 xxx-admin-ui 和 xxx-admin-service 都用到了lerna, 记录一下注意点 Needlernanpm 1. 初始化工程1mkdir temp &amp;&amp; cd temp &amp;&amp; lerna init 2. 初始化每个包 假设我们有 2 个包, 如 : 123packages - admin-1 - admin-2 分别进入 admin-1 和 admin-2 初始化: 123cd packages/admin-1 &amp;&amp; npm init -ycd packages/admin-2 &amp;&amp; npm init -y 当然, 每个包都是完整的工程, 可以自由发挥 在 admin-1 和 admin-2 的package.json中修改包名和版本 123456// admin-1 package.json&#123; \"name\": \"@laputaz/admin-1\",// 包名 \"version\": \"0.0.1\", // 起始版本号, 我用 0.0.1 开始 ...&#125; @laputaz 为 scope, 所有相同 scope 的包, 安装后会被放在 scope 目录下 admin-2 同理 3. 每个包添加内容 为两个包都增加一个 src/index.js 12// admin-1/src/index.jsconsole.log('admin-1') 12// admin-2/src/index.jsconsole.log('admin-2') 如果我们不需要对代码打包压缩等操作, 直接指定入口以及需要发布的内容即可: 12345678// in package.json&#123; \"main\": \"src/index.js\", // 发布后被引用时的入口 \"files\": [ // 需要发布的文件 \"src\", // 直接发布src的内容以及 README.md \"README.md\" ]&#125; 也可以用.npmignore指定不需要发布的内容, 区别如下 12.npmignore 该文件指定的内容将不会被发布package.json =&gt; files 字段, 该字段指定的内容将会被发布, 优先级高于.npmignore 4. 修改 lerna 配置在 lerna.json 中, 增加如下配置: 1234567891011121314151617// in lerna.json&#123; \"packages\": [ \"packages/admin-1\", \"packages/admin-2\" ], \"command\": &#123; \"bootstrap\": &#123; \"hoist\": true &#125;, \"publish\": &#123; \"message\": \"release: publish tag \", // lerna version打tag的时候的commit \"conventionalCommits\": false // &#125; &#125;, \"version\": \"independent\"&#125; 建议: packages中我们可以写 packages/* , 但经常会建立一些不用发布的demo等代码文件目录, 所以最好手动指定需要发布的包 command =&gt; bootstrap =&gt; hoist 设置为true, 可以把所有的 node_modules的内容提升到顶层, 让每个包里的node_modules看起来更干净 version 改为 independent, 让每个包版本号可以不一样 command =&gt; publish =&gt; conventionalCommits设置为false把自动生成changelog的功能关了, 太鸡肋, 因为生成的changelog可读性很差. 如果没有依赖关系,或者代码打包压缩等处理, 可以走直接第6 步发布了. 5. 处理依赖关系包之间可能存在依赖关系, 这里演示有依赖关系的情况: 更新两个包的 src/index.js, 假设 admin-2 依赖 admin-1 12// admin-1/src/index.jsexport const say1 = () =&gt; console.log('I am admin-1') &amp; 123// admin-2/src/index.jsimport &#123; say1 &#125; from '@laputaz/admin-1'say1() 更新 admin-2 的 dependencies: 123456789// admin-2 package.json&#123; \"name\": \"@laputaz/admin-2\", ... ... \"dependencies\": &#123; \"@laputaz/admin-1\": \"0.0.1\" &#125;&#125; 本地调试时, 需要为 admin-1建立一个软链接, 运行: 1lerna bootstrap 该命令会在 admin-2 的node_modules下建立指向admin-1的快捷方式: 可以发现 admin-2/node_modules/@laputa/admin-1 的内容就是 admin-1 的内容 这样不需要先发布admin-1 , 也可以在本地正常调试了. 6. 发布由于权限限制, 我们不能直接运行lerna publish 发布. 需要分两步操作. 首先保证代码均已 push 到仓库. 运行 1lerna version [ patch | minor | major | ... ] # 还有其他选项, 但主要使用了这三个 该命令会自动更新每个包的版本并打tag提交到git仓库 slack deploy channel: 1@k fab knpm_lerna_publish:xxxx.git xxxx.git为git仓库地址 然后在 npm 上就能看到发布的包了 7. 如果要发布打包后的代码我们经常需要对代码打包压缩等处理, 然后发布处理后的代码 假设, 我们对 admin-1 打包压缩, 输出文件为 lib/index.common.js 首先在 package.json修改包的入口 123&#123; \"main\": \"lib/index.common.js\",&#125; 然后需要在scripts增加一个钩子: 1234567&#123; \"scripts\": &#123; ... ... \"prepublishOnly\": \"do something here ......\" &#125;&#125; 我们在 deploy channel执行发布命令的时候, 会在远端执行 lerna publish 而 lerna publish 中又会执行 npm publish 而 prepublishOnly 这个钩子, 会在npm publish 前执行 prepublishOnly 中就可以写一些譬如: 切换node版本/ 执行 npm install &amp;&amp; npm run build等操作 8. 如果需要 changelogconventionalCommits生成的changelog是基于每个commit的, 难看且鸡肋, 所以决定手动生成. 文件: 121. changelog.md // 该文件为最终的所有的版本记录2. current.md // 当前版本的log 每次只修改 current.md 记录当前版本的更改内容 在pulish之前将 current.md 的内容放到 changelog.md中, 并清空 current.md 在工程根目录的 package.json 中增加 1234567&#123; \"scripts\": &#123; ... ... \"version\": \"cat current.md &gt;&gt;&gt; changelog.md &amp;&amp; git ad .\" &#125;&#125; 因为执行version 的时候, package中的版本号已经被更新了(即可以拿到最新的版本号), 所以可以在version钩子中操作版本文档的更新, 然后git ad .","categories":[],"tags":[]},{"title":"如何快速入门俄语","slug":"如何快速入门俄语","date":"2021-02-10T09:20:15.000Z","updated":"2021-06-14T08:28:52.077Z","comments":true,"path":"2021/02/10/如何快速入门俄语/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%BF%84%E8%AF%AD/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"如何加工一套家具","slug":"如何生产一套家具","date":"2021-02-10T09:16:01.000Z","updated":"2021-06-14T08:28:52.077Z","comments":true,"path":"2021/02/10/如何生产一套家具/","link":"","permalink":"https://laputaz.github.io/home/2021/02/10/%E5%A6%82%E4%BD%95%E7%94%9F%E4%BA%A7%E4%B8%80%E5%A5%97%E5%AE%B6%E5%85%B7/","excerpt":"","text":"what ?","categories":[],"tags":[{"name":"life","slug":"life","permalink":"https://laputaz.github.io/home/tags/life/"}]},{"title":"如何用console.log输出pornhub图标(误)","slug":"js-console-log-pornhub","date":"2019-11-29T14:26:19.000Z","updated":"2021-06-14T08:28:52.073Z","comments":true,"path":"2019/11/29/js-console-log-pornhub/","link":"","permalink":"https://laputaz.github.io/home/2019/11/29/js-console-log-pornhub/","excerpt":"","text":"console.log方法记录 起因下午写了一下shell脚本, 突然想到chrome的devtool是不是也支持字体颜色, 本着上(瞎)下(鸡)求(儿)索(搞)的精神,试了一下确实可以 尝试console.log方法是支持对打印的结果加一些简单的样式的, 如下 1console.log('%c我黄了', 'color:yellow') 复杂一点1console.log('%chello %s %s %c%s', 'color:green;font-family:Hanzipen TC', 'QQQ','T', 'background-color: #ff6600;color:#fff','How are you') 可以看到%c对应样式, %s对应字符,上面第一个参数中, 书写的顺序是%c %s %s %c %s, 所以从第二个参数开始, 传参顺序得是样式, 字符, 字符, 样式, 字符 还支持padding等属性1console.log('%c%s%cYours To Explore','color:#fff;background:#ff6600;font-weight:800;padding:10px;border-radius: 5px 0 0 5px ','KLOOK','color:#fff;background:#ff6600;font-weight:800;padding:10px 10px 10px 0;font-family:Hanzipen TC; border-radius: 0 5px 5px 0') 来了那么, 用console.log输出学习强国图标也就不是问题了. 1console.log('%cPorn %cHub','color:#fff;background:#000;font-weight:800;padding:10px;border-radius:3px','color:#000;background:#ff9900;font-weight:800;padding:3px;margin-left:-40px;border-radius:2px') 再夸张一点12let css = \"text-shadow: -1px -1px hsl(0,100%,50%), 1px 1px hsl(5.4, 100%, 50%), 3px 2px hsl(10.8, 100%, 50%), 5px 3px hsl(16.2, 100%, 50%), 7px 4px hsl(21.6, 100%, 50%), 9px 5px hsl(27, 100%, 50%), 11px 6px hsl(32.4, 100%, 50%), 13px 7px hsl(37.8, 100%, 50%), 14px 8px hsl(43.2, 100%, 50%), 16px 9px hsl(48.6, 100%, 50%), 18px 10px hsl(54, 100%, 50%), 20px 11px hsl(59.4, 100%, 50%), 22px 12px hsl(64.8, 100%, 50%), 23px 13px hsl(70.2, 100%, 50%), 25px 14px hsl(75.6, 100%, 50%), 27px 15px hsl(81, 100%, 50%), 28px 16px hsl(86.4, 100%, 50%), 30px 17px hsl(91.8, 100%, 50%), 32px 18px hsl(97.2, 100%, 50%), 33px 19px hsl(102.6, 100%, 50%), 35px 20px hsl(108, 100%, 50%), 36px 21px hsl(113.4, 100%, 50%), 38px 22px hsl(118.8, 100%, 50%), 39px 23px hsl(124.2, 100%, 50%), 41px 24px hsl(129.6, 100%, 50%), 42px 25px hsl(135, 100%, 50%), 43px 26px hsl(140.4, 100%, 50%), 45px 27px hsl(145.8, 100%, 50%), 46px 28px hsl(151.2, 100%, 50%), 47px 29px hsl(156.6, 100%, 50%), 48px 30px hsl(162, 100%, 50%), 49px 31px hsl(167.4, 100%, 50%), 50px 32px hsl(172.8, 100%, 50%), 51px 33px hsl(178.2, 100%, 50%), 52px 34px hsl(183.6, 100%, 50%), 53px 35px hsl(189, 100%, 50%), 54px 36px hsl(194.4, 100%, 50%), 55px 37px hsl(199.8, 100%, 50%), 55px 38px hsl(205.2, 100%, 50%), 56px 39px hsl(210.6, 100%, 50%), 57px 40px hsl(216, 100%, 50%), 57px 41px hsl(221.4, 100%, 50%), 58px 42px hsl(226.8, 100%, 50%), 58px 43px hsl(232.2, 100%, 50%), 58px 44px hsl(237.6, 100%, 50%), 59px 45px hsl(243, 100%, 50%), 59px 46px hsl(248.4, 100%, 50%), 59px 47px hsl(253.8, 100%, 50%), 59px 48px hsl(259.2, 100%, 50%), 59px 49px hsl(264.6, 100%, 50%), 60px 50px hsl(270, 100%, 50%), 59px 51px hsl(275.4, 100%, 50%), 59px 52px hsl(280.8, 100%, 50%), 59px 53px hsl(286.2, 100%, 50%), 59px 54px hsl(291.6, 100%, 50%), 59px 55px hsl(297, 100%, 50%), 58px 56px hsl(302.4, 100%, 50%), 58px 57px hsl(307.8, 100%, 50%), 58px 58px hsl(313.2, 100%, 50%), 57px 59px hsl(318.6, 100%, 50%), 57px 60px hsl(324, 100%, 50%), 56px 61px hsl(329.4, 100%, 50%), 55px 62px hsl(334.8, 100%, 50%), 55px 63px hsl(340.2, 100%, 50%), 54px 64px hsl(345.6, 100%, 50%), 53px 65px hsl(351, 100%, 50%), 52px 66px hsl(356.4, 100%, 50%), 51px 67px hsl(361.8, 100%, 50%), 50px 68px hsl(367.2, 100%, 50%), 49px 69px hsl(372.6, 100%, 50%), 48px 70px hsl(378, 100%, 50%), 47px 71px hsl(383.4, 100%, 50%), 46px 72px hsl(388.8, 100%, 50%), 45px 73px hsl(394.2, 100%, 50%), 43px 74px hsl(399.6, 100%, 50%), 42px 75px hsl(405, 100%, 50%), 41px 76px hsl(410.4, 100%, 50%), 39px 77px hsl(415.8, 100%, 50%), 38px 78px hsl(421.2, 100%, 50%), 36px 79px hsl(426.6, 100%, 50%), 35px 80px hsl(432, 100%, 50%), 33px 81px hsl(437.4, 100%, 50%), 32px 82px hsl(442.8, 100%, 50%), 30px 83px hsl(448.2, 100%, 50%), 28px 84px hsl(453.6, 100%, 50%), 27px 85px hsl(459, 100%, 50%), 25px 86px hsl(464.4, 100%, 50%), 23px 87px hsl(469.8, 100%, 50%), 22px 88px hsl(475.2, 100%, 50%), 20px 89px hsl(480.6, 100%, 50%), 18px 90px hsl(486, 100%, 50%), 16px 91px hsl(491.4, 100%, 50%), 14px 92px hsl(496.8, 100%, 50%), 13px 93px hsl(502.2, 100%, 50%), 11px 94px hsl(507.6, 100%, 50%), 9px 95px hsl(513, 100%, 50%), 7px 96px hsl(518.4, 100%, 50%), 5px 97px hsl(523.8, 100%, 50%), 3px 98px hsl(529.2, 100%, 50%), 1px 99px hsl(534.6, 100%, 50%), 7px 100px hsl(540, 100%, 50%), -1px 101px hsl(545.4, 100%, 50%), -3px 102px hsl(550.8, 100%, 50%), -5px 103px hsl(556.2, 100%, 50%), -7px 104px hsl(561.6, 100%, 50%), -9px 105px hsl(567, 100%, 50%), -11px 106px hsl(572.4, 100%, 50%), -13px 107px hsl(577.8, 100%, 50%), -14px 108px hsl(583.2, 100%, 50%), -16px 109px hsl(588.6, 100%, 50%), -18px 110px hsl(594, 100%, 50%), -20px 111px hsl(599.4, 100%, 50%), -22px 112px hsl(604.8, 100%, 50%), -23px 113px hsl(610.2, 100%, 50%), -25px 114px hsl(615.6, 100%, 50%), -27px 115px hsl(621, 100%, 50%), -28px 116px hsl(626.4, 100%, 50%), -30px 117px hsl(631.8, 100%, 50%), -32px 118px hsl(637.2, 100%, 50%), -33px 119px hsl(642.6, 100%, 50%), -35px 120px hsl(648, 100%, 50%), -36px 121px hsl(653.4, 100%, 50%), -38px 122px hsl(658.8, 100%, 50%), -39px 123px hsl(664.2, 100%, 50%), -41px 124px hsl(669.6, 100%, 50%), -42px 125px hsl(675, 100%, 50%), -43px 126px hsl(680.4, 100%, 50%), -45px 127px hsl(685.8, 100%, 50%), -46px 128px hsl(691.2, 100%, 50%), -47px 129px hsl(696.6, 100%, 50%), -48px 130px hsl(702, 100%, 50%), -49px 131px hsl(707.4, 100%, 50%), -50px 132px hsl(712.8, 100%, 50%), -51px 133px hsl(718.2, 100%, 50%), -52px 134px hsl(723.6, 100%, 50%), -53px 135px hsl(729, 100%, 50%), -54px 136px hsl(734.4, 100%, 50%), -55px 137px hsl(739.8, 100%, 50%), -55px 138px hsl(745.2, 100%, 50%), -56px 139px hsl(750.6, 100%, 50%), -57px 140px hsl(756, 100%, 50%), -57px 141px hsl(761.4, 100%, 50%), -58px 142px hsl(766.8, 100%, 50%), -58px 143px hsl(772.2, 100%, 50%), -58px 144px hsl(777.6, 100%, 50%), -59px 145px hsl(783, 100%, 50%), -59px 146px hsl(788.4, 100%, 50%), -59px 147px hsl(793.8, 100%, 50%), -59px 148px hsl(799.2, 100%, 50%), -59px 149px hsl(804.6, 100%, 50%), -60px 150px hsl(810, 100%, 50%), -59px 151px hsl(815.4, 100%, 50%), -59px 152px hsl(820.8, 100%, 50%), -59px 153px hsl(826.2, 100%, 50%), -59px 154px hsl(831.6, 100%, 50%), -59px 155px hsl(837, 100%, 50%), -58px 156px hsl(842.4, 100%, 50%), -58px 157px hsl(847.8, 100%, 50%), -58px 158px hsl(853.2, 100%, 50%), -57px 159px hsl(858.6, 100%, 50%), -57px 160px hsl(864, 100%, 50%), -56px 161px hsl(869.4, 100%, 50%), -55px 162px hsl(874.8, 100%, 50%), -55px 163px hsl(880.2, 100%, 50%), -54px 164px hsl(885.6, 100%, 50%), -53px 165px hsl(891, 100%, 50%), -52px 166px hsl(896.4, 100%, 50%), -51px 167px hsl(901.8, 100%, 50%), -50px 168px hsl(907.2, 100%, 50%), -49px 169px hsl(912.6, 100%, 50%), -48px 170px hsl(918, 100%, 50%), -47px 171px hsl(923.4, 100%, 50%), -46px 172px hsl(928.8, 100%, 50%), -45px 173px hsl(934.2, 100%, 50%), -43px 174px hsl(939.6, 100%, 50%), -42px 175px hsl(945, 100%, 50%), -41px 176px hsl(950.4, 100%, 50%), -39px 177px hsl(955.8, 100%, 50%), -38px 178px hsl(961.2, 100%, 50%), -36px 179px hsl(966.6, 100%, 50%), -35px 180px hsl(972, 100%, 50%), -33px 181px hsl(977.4, 100%, 50%), -32px 182px hsl(982.8, 100%, 50%), -30px 183px hsl(988.2, 100%, 50%), -28px 184px hsl(993.6, 100%, 50%), -27px 185px hsl(999, 100%, 50%), -25px 186px hsl(1004.4, 100%, 50%), -23px 187px hsl(1009.8, 100%, 50%), -22px 188px hsl(1015.2, 100%, 50%), -20px 189px hsl(1020.6, 100%, 50%), -18px 190px hsl(1026, 100%, 50%), -16px 191px hsl(1031.4, 100%, 50%), -14px 192px hsl(1036.8, 100%, 50%), -13px 193px hsl(1042.2, 100%, 50%), -11px 194px hsl(1047.6, 100%, 50%), -9px 195px hsl(1053, 100%, 50%), -7px 196px hsl(1058.4, 100%, 50%), -5px 197px hsl(1063.8, 100%, 50%), -3px 198px hsl(1069.2, 100%, 50%), -1px 199px hsl(1074.6, 100%, 50%), -1px 200px hsl(1080, 100%, 50%), 1px 201px hsl(1085.4, 100%, 50%), 3px 202px hsl(1090.8, 100%, 50%), 5px 203px hsl(1096.2, 100%, 50%), 7px 204px hsl(1101.6, 100%, 50%), 9px 205px hsl(1107, 100%, 50%), 11px 206px hsl(1112.4, 100%, 50%), 13px 207px hsl(1117.8, 100%, 50%), 14px 208px hsl(1123.2, 100%, 50%), 16px 209px hsl(1128.6, 100%, 50%), 18px 210px hsl(1134, 100%, 50%), 20px 211px hsl(1139.4, 100%, 50%), 22px 212px hsl(1144.8, 100%, 50%), 23px 213px hsl(1150.2, 100%, 50%), 25px 214px hsl(1155.6, 100%, 50%), 27px 215px hsl(1161, 100%, 50%), 28px 216px hsl(1166.4, 100%, 50%), 30px 217px hsl(1171.8, 100%, 50%), 32px 218px hsl(1177.2, 100%, 50%), 33px 219px hsl(1182.6, 100%, 50%), 35px 220px hsl(1188, 100%, 50%), 36px 221px hsl(1193.4, 100%, 50%), 38px 222px hsl(1198.8, 100%, 50%), 39px 223px hsl(1204.2, 100%, 50%), 41px 224px hsl(1209.6, 100%, 50%), 42px 225px hsl(1215, 100%, 50%), 43px 226px hsl(1220.4, 100%, 50%), 45px 227px hsl(1225.8, 100%, 50%), 46px 228px hsl(1231.2, 100%, 50%), 47px 229px hsl(1236.6, 100%, 50%), 48px 230px hsl(1242, 100%, 50%), 49px 231px hsl(1247.4, 100%, 50%), 50px 232px hsl(1252.8, 100%, 50%), 51px 233px hsl(1258.2, 100%, 50%), 52px 234px hsl(1263.6, 100%, 50%), 53px 235px hsl(1269, 100%, 50%), 54px 236px hsl(1274.4, 100%, 50%), 55px 237px hsl(1279.8, 100%, 50%), 55px 238px hsl(1285.2, 100%, 50%), 56px 239px hsl(1290.6, 100%, 50%), 57px 240px hsl(1296, 100%, 50%), 57px 241px hsl(1301.4, 100%, 50%), 58px 242px hsl(1306.8, 100%, 50%), 58px 243px hsl(1312.2, 100%, 50%), 58px 244px hsl(1317.6, 100%, 50%), 59px 245px hsl(1323, 100%, 50%), 59px 246px hsl(1328.4, 100%, 50%), 59px 247px hsl(1333.8, 100%, 50%), 59px 248px hsl(1339.2, 100%, 50%), 59px 249px hsl(1344.6, 100%, 50%), 60px 250px hsl(1350, 100%, 50%), 59px 251px hsl(1355.4, 100%, 50%), 59px 252px hsl(1360.8, 100%, 50%), 59px 253px hsl(1366.2, 100%, 50%), 59px 254px hsl(1371.6, 100%, 50%), 59px 255px hsl(1377, 100%, 50%), 58px 256px hsl(1382.4, 100%, 50%), 58px 257px hsl(1387.8, 100%, 50%), 58px 258px hsl(1393.2, 100%, 50%), 57px 259px hsl(1398.6, 100%, 50%), 57px 260px hsl(1404, 100%, 50%), 56px 261px hsl(1409.4, 100%, 50%), 55px 262px hsl(1414.8, 100%, 50%), 55px 263px hsl(1420.2, 100%, 50%), 54px 264px hsl(1425.6, 100%, 50%), 53px 265px hsl(1431, 100%, 50%), 52px 266px hsl(1436.4, 100%, 50%), 51px 267px hsl(1441.8, 100%, 50%), 50px 268px hsl(1447.2, 100%, 50%), 49px 269px hsl(1452.6, 100%, 50%), 48px 270px hsl(1458, 100%, 50%), 47px 271px hsl(1463.4, 100%, 50%), 46px 272px hsl(1468.8, 100%, 50%), 45px 273px hsl(1474.2, 100%, 50%), 43px 274px hsl(1479.6, 100%, 50%), 42px 275px hsl(1485, 100%, 50%), 41px 276px hsl(1490.4, 100%, 50%), 39px 277px hsl(1495.8, 100%, 50%), 38px 278px hsl(1501.2, 100%, 50%), 36px 279px hsl(1506.6, 100%, 50%), 35px 280px hsl(1512, 100%, 50%), 33px 281px hsl(1517.4, 100%, 50%), 32px 282px hsl(1522.8, 100%, 50%), 30px 283px hsl(1528.2, 100%, 50%), 28px 284px hsl(1533.6, 100%, 50%), 27px 285px hsl(1539, 100%, 50%), 25px 286px hsl(1544.4, 100%, 50%), 23px 287px hsl(1549.8, 100%, 50%), 22px 288px hsl(1555.2, 100%, 50%), 20px 289px hsl(1560.6, 100%, 50%), 18px 290px hsl(1566, 100%, 50%), 16px 291px hsl(1571.4, 100%, 50%), 14px 292px hsl(1576.8, 100%, 50%), 13px 293px hsl(1582.2, 100%, 50%), 11px 294px hsl(1587.6, 100%, 50%), 9px 295px hsl(1593, 100%, 50%), 7px 296px hsl(1598.4, 100%, 50%), 5px 297px hsl(1603.8, 100%, 50%), 3px 298px hsl(1609.2, 100%, 50%), 1px 299px hsl(1614.6, 100%, 50%), 2px 300px hsl(1620, 100%, 50%), -1px 301px hsl(1625.4, 100%, 50%), -3px 302px hsl(1630.8, 100%, 50%), -5px 303px hsl(1636.2, 100%, 50%), -7px 304px hsl(1641.6, 100%, 50%), -9px 305px hsl(1647, 100%, 50%), -11px 306px hsl(1652.4, 100%, 50%), -13px 307px hsl(1657.8, 100%, 50%), -14px 308px hsl(1663.2, 100%, 50%), -16px 309px hsl(1668.6, 100%, 50%), -18px 310px hsl(1674, 100%, 50%), -20px 311px hsl(1679.4, 100%, 50%), -22px 312px hsl(1684.8, 100%, 50%), -23px 313px hsl(1690.2, 100%, 50%), -25px 314px hsl(1695.6, 100%, 50%), -27px 315px hsl(1701, 100%, 50%), -28px 316px hsl(1706.4, 100%, 50%), -30px 317px hsl(1711.8, 100%, 50%), -32px 318px hsl(1717.2, 100%, 50%), -33px 319px hsl(1722.6, 100%, 50%), -35px 320px hsl(1728, 100%, 50%), -36px 321px hsl(1733.4, 100%, 50%), -38px 322px hsl(1738.8, 100%, 50%), -39px 323px hsl(1744.2, 100%, 50%), -41px 324px hsl(1749.6, 100%, 50%), -42px 325px hsl(1755, 100%, 50%), -43px 326px hsl(1760.4, 100%, 50%), -45px 327px hsl(1765.8, 100%, 50%), -46px 328px hsl(1771.2, 100%, 50%), -47px 329px hsl(1776.6, 100%, 50%), -48px 330px hsl(1782, 100%, 50%), -49px 331px hsl(1787.4, 100%, 50%), -50px 332px hsl(1792.8, 100%, 50%), -51px 333px hsl(1798.2, 100%, 50%), -52px 334px hsl(1803.6, 100%, 50%), -53px 335px hsl(1809, 100%, 50%), -54px 336px hsl(1814.4, 100%, 50%), -55px 337px hsl(1819.8, 100%, 50%), -55px 338px hsl(1825.2, 100%, 50%), -56px 339px hsl(1830.6, 100%, 50%), -57px 340px hsl(1836, 100%, 50%), -57px 341px hsl(1841.4, 100%, 50%), -58px 342px hsl(1846.8, 100%, 50%), -58px 343px hsl(1852.2, 100%, 50%), -58px 344px hsl(1857.6, 100%, 50%), -59px 345px hsl(1863, 100%, 50%), -59px 346px hsl(1868.4, 100%, 50%), -59px 347px hsl(1873.8, 100%, 50%), -59px 348px hsl(1879.2, 100%, 50%), -59px 349px hsl(1884.6, 100%, 50%), -60px 350px hsl(1890, 100%, 50%), -59px 351px hsl(1895.4, 100%, 50%), -59px 352px hsl(1900.8, 100%, 50%), -59px 353px hsl(1906.2, 100%, 50%), -59px 354px hsl(1911.6, 100%, 50%), -59px 355px hsl(1917, 100%, 50%), -58px 356px hsl(1922.4, 100%, 50%), -58px 357px hsl(1927.8, 100%, 50%), -58px 358px hsl(1933.2, 100%, 50%), -57px 359px hsl(1938.6, 100%, 50%), -57px 360px hsl(1944, 100%, 50%), -56px 361px hsl(1949.4, 100%, 50%), -55px 362px hsl(1954.8, 100%, 50%), -55px 363px hsl(1960.2, 100%, 50%), -54px 364px hsl(1965.6, 100%, 50%), -53px 365px hsl(1971, 100%, 50%), -52px 366px hsl(1976.4, 100%, 50%), -51px 367px hsl(1981.8, 100%, 50%), -50px 368px hsl(1987.2, 100%, 50%), -49px 369px hsl(1992.6, 100%, 50%), -48px 370px hsl(1998, 100%, 50%), -47px 371px hsl(2003.4, 100%, 50%), -46px 372px hsl(2008.8, 100%, 50%), -45px 373px hsl(2014.2, 100%, 50%), -43px 374px hsl(2019.6, 100%, 50%), -42px 375px hsl(2025, 100%, 50%), -41px 376px hsl(2030.4, 100%, 50%), -39px 377px hsl(2035.8, 100%, 50%), -38px 378px hsl(2041.2, 100%, 50%), -36px 379px hsl(2046.6, 100%, 50%), -35px 380px hsl(2052, 100%, 50%), -33px 381px hsl(2057.4, 100%, 50%), -32px 382px hsl(2062.8, 100%, 50%), -30px 383px hsl(2068.2, 100%, 50%), -28px 384px hsl(2073.6, 100%, 50%), -27px 385px hsl(2079, 100%, 50%), -25px 386px hsl(2084.4, 100%, 50%), -23px 387px hsl(2089.8, 100%, 50%), -22px 388px hsl(2095.2, 100%, 50%), -20px 389px hsl(2100.6, 100%, 50%), -18px 390px hsl(2106, 100%, 50%), -16px 391px hsl(2111.4, 100%, 50%), -14px 392px hsl(2116.8, 100%, 50%), -13px 393px hsl(2122.2, 100%, 50%), -11px 394px hsl(2127.6, 100%, 50%), -9px 395px hsl(2133, 100%, 50%), -7px 396px hsl(2138.4, 100%, 50%), -5px 397px hsl(2143.8, 100%, 50%), -3px 398px hsl(2149.2, 100%, 50%), -1px 399px hsl(2154.6, 100%, 50%); font-size: 40px;\";console.log(\"%cI am so happy today !\", css);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"}]},{"title":"maze-generator","slug":"js-maze-generator","date":"2019-11-01T15:10:28.000Z","updated":"2021-06-14T08:28:52.072Z","comments":true,"path":"2019/11/01/js-maze-generator/","link":"","permalink":"https://laputaz.github.io/home/2019/11/01/js-maze-generator/","excerpt":"","text":"maze-generatora plugin that generates a maze.github page","categories":[],"tags":[]},{"title":"面试-尾调用优化","slug":"tail-optimization","date":"2019-10-22T15:23:25.000Z","updated":"2021-06-14T08:28:52.072Z","comments":true,"path":"2019/10/22/tail-optimization/","link":"","permalink":"https://laputaz.github.io/home/2019/10/22/tail-optimization/","excerpt":"面试 futu 遇到的问题","text":"面试 futu 遇到的问题 场景今天去面试 futu, 被问到一题 -&gt; 参数为数字, 输出斐波那契数列对应结果, 实现了一下 1234function fibonacci(n) &#123; if (n == 1 || n == 2) return 1; return fibonacci(n - 1) + fibonacci(n - 2);&#125; 123456789然后面试官问: &quot;你觉得这个有什么问题 ?&quot;我: &quot;(⊙o⊙)…忘记判断参数类型了.&quot;面试官: &quot;不是这个问题.&quot;我: &quot;嗯..嗯...嗯.呃...这个...&quot;面试官: &quot;如果数字很大会怎么样?&quot;我: &quot;会...性能很差&quot;面试官: &quot;嗯, 会爆炸, 为什么? 那怎么改?&quot;我: &quot;嗯..嗯...嗯.呃...不会...&quot;面试官: &quot;你回去查一下吧.&quot; Game Over回来查原来 有个概念叫尾调用优化, 果然还是太菜 什么是尾调用 尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。尾调用-阮一峰 尾调用之所以与其他调用不同，就在于它的特殊的调用位置。我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数 A 的内部调用函数 B，那么在 A 的调用记录上方，还会形成一个 B 的调用记录。等到 B 运行结束，将结果返回到 A，B 的调用记录才会消失。如果函数 B 内部还调用函数 C，那就还有一个 C 的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。 递归的计算过程（recursive process）包含了两个阶段，先逐级扩展（expansion），构造起一个由被推迟的操作组成的链条（会被解释器保存在堆栈里），然后在收缩（contraction）阶段逐级回溯执行那些操作。随着递归计算步骤的增多，这种方法消耗的资源会越来越大，而且会包含越来越多的冗余操作，上面那个求斐波那契数列的例子（在 SICP 里被称作“树形递归”）在这方面问题尤其严重，因为它的计算步骤会随着参数而指数性的增长。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。 优化-&gt;尾调用1234567function lastFibonacci(n, acc1, acc2) &#123; if (n == 1) return acc1; return lastFibonacci(n - 1, acc2, acc1 + acc2);&#125;lastFibonacci(6, 1, 1); //8lastFibonacci(7, 1, 1); //13 这样每次都要输入 1,1,可以用柯里化或 es6 加柯里化或 es61234567891011121314151617// 再封装一层柯里化-----------function curringF(acc1, acc2) &#123; return function(n) &#123; return lastFibonacci(n, acc1, acc2); &#125;;&#125;let func = curringF(1, 1);func(6); // 8func(7); // 13//或 es6---------function lastFibonacci(n, acc1 = 1, acc2 = 1) &#123; if (n == 1) return acc1; return lastFibonacci(n - 1, acc2, acc1 + acc2);&#125;lastFibonacci(7); //13 啊啊啊啊啊啊啊啊啊啊啊","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"}]},{"title":"一个简单的微信小程序-赛博朋克2077倒计时-以及简单的云开发","slug":"cyberpunk-wechat","date":"2019-10-21T16:49:13.000Z","updated":"2021-06-14T08:28:52.071Z","comments":true,"path":"2019/10/22/cyberpunk-wechat/","link":"","permalink":"https://laputaz.github.io/home/2019/10/22/cyberpunk-wechat/","excerpt":"闲来无事, 做了一个赛博朋克 2077 发售倒计时页面","text":"闲来无事, 做了一个赛博朋克 2077 发售倒计时页面 AppID申请到一个小程序后, 会对应一个 AppID 基本目录结构1234- cloudfunctions 云函数目录- miniprogram 开发目录- README.md 描述项目- project.config.json 项目配置 cloudfunctions结构如图, 每一个云函数会新建一个目录, index.js 为入口, login / openapi 是自带的, 可以获取 AppID 等 miniprogram结构如图:images 存放静态图片miniprogram_npm 是 npm 安装的依赖构建 node_module 后生成的库文件目录pages 下编写各个界面style 下存储了一些样式文件app.js / app.json 分别是程序入口 和主界面配置 以 app.json 为例 1234567891011121314151617181920212223242526272829&#123; \"pages\": [\"pages/imghander/imghander\", \"pages/base/base\"], \"window\": &#123; \"backgroundColor\": \"#F6F6F6\", \"backgroundTextStyle\": \"light\", \"navigationBarBackgroundColor\": \"#faf003\", \"navigationBarTitleText\": \"Cyberpunk 2077\", \"navigationBarTextStyle\": \"white\" &#125;, \"sitemapLocation\": \"sitemap.json\", \"tabBar\": &#123; \"color\": \"#000000\", \"selectedColor\": \"#000000\", \"list\": [ &#123; \"pagePath\": \"pages/imghander/imghander\", \"text\": \"2077\", \"iconPath\": \"images/film.png\", \"selectedIconPath\": \"images/film-actived.png\" &#125;, &#123; \"pagePath\": \"pages/base/base\", \"text\": \"Cyberpunk\", \"iconPath\": \"images/profile.png\", \"selectedIconPath\": \"images/profile-actived.png\" &#125; ] &#125;&#125; pages属性 定义界面路径, 相当于路由 tabBar属性定义了底栏相关的属性window属性定义了标题栏的文字和颜色 , 文字颜色 navigationBarTextStyle 只能是 black 或 white 页面目录 pages以 pages 下的 base 为例一个页面初始化会包含四个文件 1234js - &gt; 页面逻辑json -&gt; 页面配置, 如安装vant库后, usingComponents 可以引入需要的组件wxml -&gt; 页面结构wxss -&gt; 页面样式 下面看一下一个 js 文件的内容 pages=&gt;页面=&gt;js以 pages=&gt;base=&gt;base.js 为例, 结构如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// pages/base/base.jsconst db = new wx.cloud.database();Page(&#123; /** * 页面的初始数据 */ data: &#123;&#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function(options) &#123;&#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function() &#123;&#125;, /** * 生命周期函数--监听页面显示 */ onShow: function() &#123;&#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function() &#123;&#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function() &#123;&#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function() &#123;&#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function() &#123;&#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function() &#123;&#125;&#125;); 预置了很多生命周期函数 效果 云开发云开发环境创建的时候, 一个账号可以提供两个环境, 每个环境可以设置 id 云数据库json 形式数据库, 每一条数据都是 json 格式的对象 , 与关系型数据库差异如图, 基于 mongoDB关系型数据库更适合表之间有复杂的关联关系, 文档型更适合频繁的读写操作, 效率高一些包含以下数据类型在小程序端操作会有权限控制, 而云函数操作则有完全的读写控制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//初始化const db = wx.cloud.database(&#123; env: \"dh\" &#125;); // 传入环境名// 插入数据, 可以用毁掉的写法, 也可以用promise写法// 插入的数据会有 id 主键 和 _openid 标识插入的用户db.collection(\"user\").add(&#123; data: &#123; name: \"dh\", time: \"2019\" &#125;, success: res =&gt; &#123; console.log(res); &#125;, fail: err =&gt; &#123; console.log(err); &#125;&#125;);// promise写法db.collection(\"user\") .add(&#123; data: &#123; name: \"dh\", time: \"2019\" &#125; &#125;) .then(res =&gt; &#123; console.log(res); &#125;) .catch(err =&gt; &#123; console.log(err); &#125;);// 更新数据, doc拿到记录db.collection(\"user\") .doc(\"as1h35idf4g56ahafhjioasdf\") .update(&#123; data: &#123; name: \"dh1\", time: \"2019\" &#125; &#125;);// 查找db.collection(\"user\") .where(&#123; name: \"dh1\" &#125;) .get();// 删除 多条数据删除, 需要在云函数进行db.collection(\"user\") .doc(\"as1h35idf4g56ahafhjioasdf\") .remove(); 云函数云函数, 保存在云 云存储云存储能力 wx.cloud.uploadFile // 上传 wx.cloud.downloadFile //下载 wx.cloud.deleteFile // 删除 wx.cloud.getTempFileUrl // 临时路径 …. …. 举个简单的例子-上传用户打开相册选择图片 1wx.chooseImage(); // promise 可以拿到文件临时路径 上传至云存储 12345678wx.cloud.uploadFile(&#123; ... filePath: '' // 传入上一步读取的文件临时路径 ... ...&#125;).then(res =&gt; &#123; console.log(res.fileID)&#125;) // promise 可以拿到文件的 fileID 拿到 fileID 存到云数据库, 便于操作(fileID 可以直接用于 image 组件的 src) 12db.collection('image').add(&#123;fileID:fileID&#125;) // 在新建的image表中插入记录&lt;image src=\"&#123;fileID&#125;\"&gt;&lt;/image&gt; //可展示 举个简单的例子-下载通过 data-xxx 自定义属性 1&lt;button data-fileid=\"agsyuadi123asda\" bindTap=\"download\"&gt;下载&lt;/button&gt; 使得点击的时候通过 event 获取到文件的 fileID, downloadFile 方法拿到 filePath, 保存到本地 123456789download(e)&#123; wx.cloud.downloadFile(&#123; fileID: e.target.dataset.fileid &#125;).then(res =&gt; &#123; // wx.saveImageToPhotoAlbum(&#123; //保存 filePath: res.filePath &#125;) &#125;)&#125;","categories":[],"tags":[{"name":"wechat","slug":"wechat","permalink":"https://laputaz.github.io/home/tags/wechat/"}]},{"title":"深拷贝和数组扁平化","slug":"flat-and-deepclone","date":"2019-08-22T15:26:35.000Z","updated":"2021-06-14T08:28:52.071Z","comments":true,"path":"2019/08/22/flat-and-deepclone/","link":"","permalink":"https://laputaz.github.io/home/2019/08/22/flat-and-deepclone/","excerpt":"手写一遍, 方便记忆 ~","text":"手写一遍, 方便记忆 ~ 问题手写一遍, 方便记忆 ~ 深拷贝 递归 123456789101112131415const deepClone = obj =&gt; &#123; let res = Array.isArray(obj) ? [] : &#123;&#125;; if (obj &amp;&amp; typeof obj === \"object\") &#123; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; res[key] = typeof obj[key] === \"object\" ? deepClone(obj[key]) : obj[key]; &#125; &#125; &#125; return res;&#125;;let obj = &#123; a: 1, b: &#123; w: 4 &#125; &#125;;console.log(deepClone(obj)); JSON.stringify() / JSON.parse() 12345678let obj = &#123; a: 1, b: &#123; w: 4 &#125; &#125;;let obj1 = JSON.parse(JSON.stringify(obj));console.log(obj1);// 此方法问题在于, 若属性的值为undefined, 会造成属性丢失let obj2 = &#123; a: 1, b: &#123; w: 4, k: undefined &#125; &#125;;let obj3 = JSON.parse(JSON.stringify(obj2));console.log(obj3); // &#123; a: 1, b: &#123; w: 4 &#125; &#125; , //k丢失 另外, 以前项目中用过 angular1.x , 其中有 angular.copy 方法, 同样可以深拷贝 1let obj5 = angular.copy(obj2); 扁平化 简单类型, toString() / join() 12345678910// 只适用于每一项类型相同, 且均为简单类型let arr = [1, 5, [8, 8, 6, [6, 4, 3]]];let arr1 = arr .toString() .split(\",\") .map(Number);let arr2 = arr .join(\",\") .split(\",\") .map(Number); reduce 12345678const flatten = arr =&gt; &#123; return arr.reduce((cur, next) =&gt; &#123; return cur.concat(Array.isArray(next) ? flatten(next) : next); &#125;, []);&#125;;console.log(flatten([1, 5, [8, 8, 6, [6, 4, 3]]]));// [ 1, 5, 8, 8, 6, 6, 4, 3 ] 递归 1234567891011const flatt = arr =&gt; &#123; let res = []; arr.forEach(it =&gt; &#123; if (Array.isArray(it)) &#123; res = [...res, ...flatt(it)]; &#125; else &#123; res = [...res, it]; &#125; &#125;); return res;&#125;; flat 最简单的方法, es6 文档中有, 但网络上很少提及 12// flat参数可以规定扁平化几层, 默认1层let arr = [1, 5, [8, 8, 6, [6, 4, 3, &#123; a: 1, b: 2 &#125;]]].flat(Infinity);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"}]},{"title":"cookie的查看和操作","slug":"cookie的查看和操作","date":"2018-10-21T16:42:32.000Z","updated":"2021-06-14T08:28:52.070Z","comments":true,"path":"2018/10/22/cookie的查看和操作/","link":"","permalink":"https://laputaz.github.io/home/2018/10/22/cookie%E7%9A%84%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%93%8D%E4%BD%9C/","excerpt":"之前面试的时候问到，cookie 有哪些属性， 怎么删除一个 cookie， 答的吞吞吐吐， 整理一下","text":"之前面试的时候问到，cookie 有哪些属性， 怎么删除一个 cookie， 答的吞吞吐吐， 整理一下 cookie 查看以 github 为例： cookie 的字段namecookie 的名字，一个域名下绑定的 cookie，name 不能相同，相同的 name 的值会被覆盖掉（但是 name 相同，只要 cookie 的 domain ，path ， secure 有一项不同，就是不同的 cookie） value表示 cookie 的值，cookie 的值要被编码， 但不是必须的。 cookie 规定是名称/值是不允许包含分号，逗号，空格的，为了不给用户到来麻烦，考虑服务器的兼容性，cookie 的数据都最好编码。 12345678// 例如 tz 设置为 广东;shenzhen, 有中文也有分号, 就需要编码document.cookie = `tz=$&#123;encodeURIComponent(\"广东;shenzhen\")&#125;`;console.log(document.cookie);// tz=%E5%B9%BF%E4%B8%9C%3Bshenzhenconsole.log(decodeURIComponent(document.cookie));// tz=广东;shenzhen domaincookie 绑定的域名，如果没有设置，就会自动绑定到执行语句的当前域，cookie 有跨域的限制， 但不会判断端口名 pathpath 这个属性默认是’/‘，这个值匹配的是 web 的路由，举个例子： 1234&#x2F;&#x2F;默认路径www.baidu.com&#x2F;&#x2F;blog路径www.baidu.com&#x2F;blog &#x2F;&#x2F;当路径设置成&#x2F;blog的时候，其实它会给&#x2F;blog、&#x2F;blogabc等等的绑定cookie expires/max-age默认情况下， 设置的 cookie 的expires/max-age为session， 也就是关闭浏览器后，该 cookie 会被删除 如果想要 cookie 存在一段时间，那么你可以通过设置 expires 属性为未来的一个时间节点(GMT 时间) 1document.cookie = `mycookie=gg;expires=$&#123;new Date(2020, 08, 1).toGMTString()&#125;`; 但这个属性已经逐渐被 max-age 取代；max-age，是以秒为单位，max-age 为正数时，cookie 会在 max-age 秒之后，被删除，当 max-age 为负数时，表示的是临时储存，不会生出 cookie 文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭，cookie 就会消失，当 max-age 为 0 时，又会发生什么呢，删除 cookie，因为 cookie 机制本身没有设置删除 cookie，失效的 cookie 会被浏览器自动从内存中删除，所以，它实现的就是让 cookie 失效。 利用过期时间可以用来删除 cookie： 12345678// 把expires时间设置为过去的时间let date = new Date();let sec = date.getTime();date.setTime(sec - 1);document.cookie = `mycookie=;expires=$&#123;date.toGMTString()&#125;;`;// 或者把 max-age 设置为0或负数document.cookie = `mycookie=;max-age=0;`; secure当这个属性设置为 true 时，此 cookie 只会在 https 和 ssl 等安全协议下传输 HttpOnly这个属性设置为 true，就不能通过 js 脚本来获取 cookie 的值，能有效的防止 xss 攻击（也就是用户通过 xss 输入的恶意代码不能获取到 cookie）, 以上图为例， _gh_sess, logged_in通过 document.cookie 是获取不到的， 另外， document.cookie 只能拿到非 HttpOnly 的键值 上述属性，除了 name，value，其他可以设置值(指通过 js)(HttpOnly 不行)， 但取不到值","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"cookie","slug":"cookie","permalink":"https://laputaz.github.io/home/tags/cookie/"}]},{"title":"不可扩展对象、密封对象、冻结对象","slug":"防止对象被修改","date":"2018-10-21T09:29:56.000Z","updated":"2018-10-21T09:29:56.000Z","comments":true,"path":"2018/10/21/防止对象被修改/","link":"","permalink":"https://laputaz.github.io/home/2018/10/21/%E9%98%B2%E6%AD%A2%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BF%AE%E6%94%B9/","excerpt":"本文介绍的是一些防止对象被修改的方法","text":"本文介绍的是一些防止对象被修改的方法 不可扩展对象 Object.preventExtensions不可添加新属性 123456let obj = &#123; a: 1, b: 2 &#125;;Object.preventExtensions(obj);obj.c = 1;obj; // &#123;a:1,b:2&#125;// Object.isExtensible检测是否可扩展console.log(Object.isExtensible(obj)); // false 密封对象 Object.seal密封对象不可扩展，而且已有的属性成员[[configurable]]特性将被设置成 false（意味着不能删除属性和方法，但是可修改已有属性值） 12345678910111213141516171819202122let obj = &#123; a: \"a\", b: [1, 2]&#125;;// 密封Object.seal(obj);// 删除delete obj.a; // false// 可以删引用类型的属性delete obj.b[1]; // true.obj.b; // &#123;a: \"a\", b: [1, empty]&#125;obj.b[1]; // undefinedobj.a = \"c\";obj.a; // c// 查看描述, 可以看到configurable为falseObject.getOwnPropertyDescriptors(obj);//a: &#123;value: \"a\", writable: true, enumerable: true, configurable: false&#125;//b: &#123;value: Array(2), writable: true, enumerable: true, configurable: false&#125; 冻结对象 Object.freeze最严格的防止篡改级别是冻结对象，冻结的对象既不可以扩展，又是密封的，而且对象数据属性的[[writable]]特性会被设置为 false。 如果定义[[Set]]函数，访问器属性仍然是可写的 1234567891011121314151617181920let obj = &#123; a: \"a\", b: [1, 2]&#125;;Object.freeze(obj);// 不可修改obj.a = \"c\";obj.a; // 'a'// 不可删除delete obj.a; // false// 不可新增obj.c = 1;// 查看描述, 可以看到configurable为false, writable也为 falseObject.getOwnPropertyDescriptors(obj);// a: &#123;value: \"a\", writable: false, enumerable: true, configurable: false&#125;// b: &#123;value: Array(2), writable: false, enumerable: true, configurable: false&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"}]},{"title":"图片下载/预览简单实现 , 以及FileReader转换文件的方法","slug":"image-preview","date":"2018-10-21T09:29:56.000Z","updated":"2021-06-14T08:28:52.071Z","comments":true,"path":"2018/10/21/image-preview/","link":"","permalink":"https://laputaz.github.io/home/2018/10/21/image-preview/","excerpt":"图片下载/预览简单实现 , 以及 FileReader 转换文件的方法","text":"图片下载/预览简单实现 , 以及 FileReader 转换文件的方法 根据路径下载思路: 通过 new Image()对象, src 赋予路径 监听将 Image 对象 onload 事件, 画在 canvas 上, 再使用 canvas.toDataURL 转换为 base64 格式(可设置图片类型和图片质量), 构建 a 标签, 点击 a 标签下载(a 标签需要设置 download 属性) 1234567891011121314151617// 新建canvas对象, 取到2d画布var canvas = document.getElementsByTagName(\"canvas\")[0];var ctx = canvas.getContext(\"2d\");// 新建图片var Img = new Image();Img.src = \"a.png\";// 转换为 base64Img.onload = function() &#123; canvas.width = Img.width; canvas.height = Img.height; ctx.drawImage(Img, 0, 0, canvas.width, canvas.height); var base = canvas.toDataURL(\"image/png\"); var $a = document.createElement(\"a\"); $a.setAttribute(\"href\", base); $a.setAttribute(\"download\", \"downloadImg\"); document.getElementById(\"download\").click();&#125;; 上传预览后下载思路: 通过 input 标签, type=file 监听 change 事件, 通过事件对象拿到图片的 file 对象(e.target.files) new FileReader 读取文件 调用 FileReader 的 readAsDataURL 方法 在 FileReader 对象的 onload 事件拿到转换后的 base64 格式 赋予图片标签 src 预览 构建 a 标签, 点击 a 标签下载 下面随便写一下 1234&lt;img id=\"img\" src=\"\" alt=\"\" /&gt;&lt;input id=\"file-select\" type=\"file\" placeholder=\"请选择图片\" /&gt;&lt;button&gt;下载&lt;/button&gt;&lt;script src=\"a.js\"&gt;&lt;/script&gt; 1234567891011121314151617181920212223var $input = document.getElementById(\"file-select\");var src = \"\";$input.addEventListener(\"change\", function(e) &#123; var reader = new FileReader(); reader.readAsDataURL(e.target.files[0]); reader.onload = function(ev) &#123; var imgEle = document.getElementById(\"img\"); imgEle.setAttribute(\"width\", \"200\"); imgEle.setAttribute(\"height\", \"100\"); imgEle.src = ev.target.result; src = imgEle.src; &#125;;&#125;);function download() &#123; var el = document.createElement(\"a\"); el.setAttribute(\"href\", src); el.setAttribute(\"download\", \"test\"); el.click();&#125;var btn = document.getElementsByTagName(\"button\")[0];btn.addEventListener(\"click\", download); 粗糙的效果: FileReaderFileReader 接收 File 或 Blob 对象 1234fr.readAsDataURL(); //result属性中将包含一个data:URL格式的字符串, 文本文档也可以转换为 base64fr.readAsBinaryString() //result属性中将包含所读取文件的原始二进制数据fr.readAsText() //result属性中将包含一个字符串以表示所读取的文件内容fr.readAsArrayBuffer() //result 属性中保存的将是被读取文件的 1234567891011121314(function() &#123; var dataUrl; var file = document.querySelector(\"input.upload\").files[0]; var fr = new FileReader(); fr.readAsDataURL(); //result属性中将包含一个data: URL格式的字符串, 文本文档也可以转换为 base64 //fr.readAsBinaryString() //result属性中将包含所读取文件的原始二进制数据 //fr.readAsText() //result属性中将包含一个字符串以表示所读取的文件内容 //fr.readAsArrayBuffer() //result 属性中保存的将是被读取文件的 fr.onload(function() &#123; //文件读取成功回调 dataUrl = fr.result; //result属性为data:URL格式,与读取方式有关 document.querySelector(\"img.previewImg\").src = dataUrl; &#125;);&#125;);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"}]},{"title":"try里面放return，finally还会执行吗","slug":"try-catch-return","date":"2018-10-17T15:29:54.000Z","updated":"2021-06-14T08:28:52.072Z","comments":true,"path":"2018/10/17/try-catch-return/","link":"","permalink":"https://laputaz.github.io/home/2018/10/17/try-catch-return/","excerpt":"try 里面放 return，finally 还会执行吗","text":"try 里面放 return，finally 还会执行吗 123456789101112// return 执行了但是没有立即返回，而是先执行了finallyfunction kaimo() &#123; try &#123; return 0; &#125; catch (err) &#123; console.log(err); &#125; finally &#123; console.log(\"a\"); &#125;&#125;console.log(kaimo()); // a 0 123456789101112// finally 中的 return 覆盖了 try 中的 return。function kaimo() &#123; try &#123; return 0; &#125; catch (err) &#123; console.log(err); &#125; finally &#123; return 1; &#125;&#125;console.log(kaimo()); // 1","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"}]},{"title":"Vue源码整理, 数据代理和响应式","slug":"vue-principle","date":"2018-09-22T15:28:34.000Z","updated":"2021-06-14T08:28:52.072Z","comments":true,"path":"2018/09/22/vue-principle/","link":"","permalink":"https://laputaz.github.io/home/2018/09/22/vue-principle/","excerpt":"最近看了一下 Vue 相关的东西 ,整理一下流程","text":"最近看了一下 Vue 相关的东西 ,整理一下流程 1. 数据代理 -&gt; Object.defineProperty()123456789101112131415let vm = new Vue(&#123; data: &#123; a: 0 &#125;&#125;);// 为什么能通过 vm.a 访问到 data 中的 a ?// 因为会通过 Object.defineProperty 设置了数据代理Object.defineProperty(vm, \"a\", &#123; get() &#123; return data.a; &#125;, set(val) &#123; data.a = val; &#125;&#125;); 2. 模板解析 -&gt; NodeType -&gt; Reg -&gt; moustache -&gt; v-on -&gt; bind/html/class/textVue 2 是虚拟节点 VNode 12345678910111213let vm = new Vue(&#123; el: \"#my\", data: &#123; a: 0 &#125;&#125;);// 拿到 el 对应的模板以后, createDocumentFragment() 产生一个Dom片段// 再将el所有子节点插入到该Fragment// 遍历Fragment中每个节点// 文本 =&gt; 匹配&#123;&#123;&#125;&#125;// 元素 =&gt; 编译元素的指令// 普通指令/事件指令 =&gt; 编译完后删除该指令// 包含子节点 =&gt; 继续迭代 3. 数据绑定和响应式 -&gt; 使用数据劫持的技术实现一旦更新 data 中某个属性数据, 所有界面直接使用或间接使用该属性的节点会更新基本思路: 通过 defineProperty 监视 data 中所有层级数据的变化, 变化则更新界面 1234vm.a &#x3D; 3&#x3D;&gt; vm.a.set &#x2F;&#x2F; 更新data中的a&#x3D;&gt; vm.data.a &#x3D; 3&#x3D;&gt; vm.data.a.set &#x2F;&#x2F;更新界面 12345678910111213141516171819202122232425262728293031增加observe &#x3D;&gt; 递归对每个属性 Object.defineProperty 增加 get set, 并且设为configurable:false除了事件指令, 每个指令&#x2F;表达式 &#x3D;&gt; 增加watcherDep -&gt; &#123; 实例创建时间 &#x3D;&gt; 给data中每个属性增加observe数据劫持时(增加get,set)创建的, 在模板编译之前, new watcher()以前 数量 &#x3D;&gt; 与data中属性一一对应(所有层级) 结构 &#x3D;&gt; &#123; id: 标识 uid subs: [] subscribe订阅者数组, 内容是 watchers &#x2F;&#x2F; 即需要更新的所有相关表达式 &#125;&#125;watcher -&gt; &#123; 实例创建时间 &#x3D;&gt; 初始化解析大括号表达式&#x2F;一般指令时创建 数量 &#x3D;&gt; 与大括号表达式&#x2F;一般指令一一对应 结构 &#x3D;&gt; &#123; cb: cb 界面更新回调 vm: vm exp: 对应的表达式 depIds: &#123;&#125; 相关的n个dep &#x2F;&#x2F; 主要用于判断关系是否建立, 避免再次建立dep watcher关系 value: get() 当前表达式value &#125;&#125;Dep与Watcher关系关系 -&gt; data属性 -&gt; 一个dep -&gt; n个watcher(属性在模板多次使用) 表达式 -&gt; watcher -&gt; n个dep(多层表达式, 如a.b, 对应了两个dep)建立 -&gt; 初始化data数据 -&gt; 每个数据增加dep, 并增加 get, set -&gt; 编译模板 -&gt; 拿到表达式 -&gt; 每个表达式增加一个watcher -&gt; watcher初始化会有个value属性 -&gt; 该value属性调用了dep的get方法 -&gt; dep的get方法depend() -&gt; 通过watcher的depIds判断关系是否建立 -&gt; dep 保存watcher到subs -&gt; watcher 的depIds保存dep响应式 -&gt; vm.name &#x3D; &#39;abc&#39; -&gt; data中name属性值变化 -&gt; name的 set() -&gt; dep.notify() -&gt; dep中subs数组中每个watcher进行update() -&gt; watcher.cb 回调 -&gt; updater更新界面 总结整体实现分为已下步骤 实现一个 Observer，对数据进行劫持，通知数据的变化（将使用的要点为：Object.defineProperty()方法） 实现一个 Compile，对指令进行解析，初始化视图，并且订阅数据的变更，绑定好更新函数 实现一个 Watcher，将其作为以上两者的一个中介点，在接收数据变更的同时，让 Dep 添加当前 Watcher，并及时通知视图进行 update 实现一些 VUE 的其他功能（Computed、menthods） 实现 MVVM，整合以上几点，作为一个入口函数","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://laputaz.github.io/home/tags/vue/"}]},{"title":"::before ::after 以及 clear:left, right, both","slug":"css-float-clear-fix","date":"2018-08-30T15:33:01.000Z","updated":"2021-06-14T08:28:52.070Z","comments":true,"path":"2018/08/30/css-float-clear-fix/","link":"","permalink":"https://laputaz.github.io/home/2018/08/30/css-float-clear-fix/","excerpt":"对于::before, ::after, 发现以前理解错了，在这里记录一下。","text":"对于::before, ::after, 发现以前理解错了，在这里记录一下。 起因早上看 float 布局时， 突然想起以前学的 clear:both 清除浮动， 其中有个利用 ::after 伪元素的方法， 我动手试了一下,一开始 ，我写成这样： 123&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910.parent &#123; border: 5px solid #000;&#125;.left &#123; float: left; width: 200px; height: 100px; background-color: yellow; opacity: 0.7;&#125; 效果： 父元素高度没撑开， 现在用上clear: both试试，然后，我写成了这样： 123&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.parent &#123; border: 5px solid #000;&#125;.left &#123; float: left; width: 200px; height: 100px; background-color: yellow; opacity: 0.7;&#125;.left::after &#123; content: \"\"; clear: both;&#125; 效果：还是没撑开啊 ？ nmd, wsm ? ::after不是给left加了一个兄弟吗， clear：both 不是清除前面的浮动效果吗？查了一下发现， 我理解错了 !::after给元素增加一个子元素（而不是兄弟元素），放在最后。。。。改成这样就好了 123&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415.parent &#123; border: 5px solid #000;&#125;.left &#123; float: left; width: 200px; height: 100px; background-color: yellow; opacity: 0.7;&#125;.parent::after &#123; content: \"\"; display: block; clear: both;&#125; OK, 撑开了，看东西还是要细心。。 ::before 和 ::after网络上搜的很多文章的解释是: 在元素前或后产生一个伪元素；这种解释不严谨， 让我误以为，::before 和 ::after生成的元素是兄弟元素 ;现在才发现是不对的（捂脸），来看一下 MDN 上的解释 In CSS, ::after creates a pseudo-element that is the last child of the selected element. It is often used to add cosmetic content to an element with the content property. It is inline by default. CSS 伪元素::after 用来创建一个伪元素，作为已选中元素的最后一个子元素。通常会配合 content 属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素。 生成的是子元素。。。::before放在第一位， ::after放在最后。 clear: both为什么clear: both能撑开父级 ？先看一下clear在MDN的解释： clear 属性指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面。clear 属性适用于浮动和非浮动元素。 The clear CSS property sets whether an element must be moved below (cleared) floating elements that precede it. The clear property applies to floating and non-floating elements. 也就是说，如果在一个元素加上 clear 属性，那么 清除该元素前面的元素带来的浮动影响， 放在浮动元素的后面 这里， 网络上的说法：clear：both 会消除该元素两侧的浮动， 这是错误的，clear 只能消除在它前面的元素的浮动 ！否则， 为甚么网上搜的所有的方法都用::after, 而不是::before 呢， 因为::before 生成第一个子元素， 浮动元素都在它之后， 根本无法消除。 clear:left，clear:right, clear: both 三者区别在哪？ 直接看效果。 1. clear: left清除前面的float：left元素的影响，可以看到，父容器高度以左浮动2为准了， 此时右浮动还是超出了容器 。 123456&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;左浮动1&lt;/div&gt; &lt;div class=\"left\" style=\"height: 80px\"&gt;左浮动2&lt;/div&gt; &lt;div class=\"right\"&gt;右浮动&lt;/div&gt; &lt;div class=\"clear\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.parent &#123; border: 2px solid #656565; width: 500px; margin: 0 auto;&#125;.left &#123; float: left; height: 50px; width: 100px; background: #2ecc71; opacity: 0.8;&#125;.right &#123; float: right; height: 120px; width: 100px; background: #e74c3c; opacity: 0.8;&#125;.clear &#123; clear: left;&#125; 2. clear: right同理, 清除该元素前面, 右浮动元素的影响, 此时父容器高度被右浮动撑开了(其实应该说，clear:both 元素被放在右浮动元素的后面了, 所以撑开了) 123456&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;左浮动1&lt;/div&gt; &lt;div class=\"left\" style=\"height: 120px\"&gt;左浮动2&lt;/div&gt; &lt;div class=\"right\"&gt;右浮动&lt;/div&gt; &lt;div class=\"clear\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.parent &#123; border: 2px solid #656565; width: 500px; margin: 0 auto;&#125;.left &#123; float: left; height: 50px; width: 100px; background: #2ecc71; opacity: 0.8;&#125;.right &#123; float: right; height: 80px; width: 100px; background: #e74c3c; opacity: 0.8;&#125;.clear &#123; clear: right;&#125; 3. clear: both同理, 清除前面的所有浮动元素影响 123456&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;左浮动1&lt;/div&gt; &lt;div class=\"left\" style=\"height: 120px\"&gt;左浮动2&lt;/div&gt; &lt;div class=\"right\"&gt;右浮动&lt;/div&gt; &lt;div class=\"clear\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.parent &#123; border: 2px solid #656565; width: 500px; margin: 0 auto;&#125;.left &#123; float: left; height: 50px; width: 100px; background: #2ecc71; opacity: 0.8;&#125;.right &#123; float: right; height: 80px; width: 100px; background: #e74c3c; opacity: 0.8;&#125;.clear &#123; clear: both;&#125; 看东西不认真会导致反复和浪费时间。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://laputaz.github.io/home/tags/css/"}]},{"title":"angular 1.x 项目总结","slug":"js-angular-1-summary","date":"2018-07-12T15:31:18.000Z","updated":"2021-06-14T08:28:52.070Z","comments":true,"path":"2018/07/12/js-angular-1-summary/","link":"","permalink":"https://laputaz.github.io/home/2018/07/12/js-angular-1-summary/","excerpt":"","text":"当年第一个项目使用angular 1.46做的，在这里记录一下， 免得忘了 结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768- common - appConfig // 处理自定义路由格式 - stateConfig // 与SEP平台对接， 中间件控制器 -&gt; 前端路由 - menuConfig.js // 菜单配置- config - quality-analysis - config.js - view.html - health - service-warning - ... - ... - // 所有业务（页面）目录- router - routerConfig.js // 路由- controller - indexController.js - baseController.js- views - documents // 帮助文档（每个页面的） - templates - layouts // 页面布局 - subLayouts // 子布局- directives - comCharts001.js - comCharts002.js - comTable001.js - ... - ... - // 所有组件- services - httpService.js // 请求模块 - layoutService.js // 处理模板 - componentService.js // 处理组件 - dataService.js // 处理数据源 - excelService.js // 处理前端生成excel - ... - ... - ...- themes - css- lib - angular-ui-router.js // 路由 - tinyui // 集成了angular / 以及UI组件 - require.js- assets - images - svgs- main.js // 入口- app.js- index.html // 入口 流程123456789101112131415161718192021222324252627=&gt; index.html=&gt; main.js -&gt; 全局变量 -&gt; 鉴权 / 获取地图数据 -&gt; angular.brootstrap() 挂载元素=&gt; app.js -&gt; app = angular.mudule() 定义主模块 -&gt; app.services() 定义services -&gt; app.filter() 定义过滤器 -&gt; app.controller(index) 定义主控制器=&gt; appConfig.js -&gt; 将 routerConfig 中的路由配置处理为angular-ui-router格式 -&gt; 引入菜单=&gt; 打开某路由=&gt; baseController.js -&gt; 读取config文件夹中的业务配置 -&gt; 定义顶层事件分发, 监听所有子级控制器的消息传播, 并转发 -&gt; 通过 layoutService.js ,componentService.js , dataService.js // 分别处理布局/组件/数据源, 生成页面控制器 -&gt; 定义includes字段以引入公共模板=&gt; config文件夹 -&gt; 页面生成通过ng-includes 问题开发中还是遇到了很多问题的: 一个页面通过多个html使用ng-includes层层嵌套, 看似可复用, 实际上没有 webpack.gulp 等支持, 会产生大量零件碎片, 严重拖慢加载速度 组件组织方式均写到 directives, 并且内部耦合太重, 稍微的功能不符合, 便需要重新写一个类似的 config 文件存在大量的重复代码, 影响代码重复率检测 没有全局数据流管理, 两个控制器通信过分依赖 baseController 顶层, 导致 baseController 本为公共, 却写了大量 if else 特殊判断 类似弹窗这种组件, 不是一对多的, 而是重复写了非常多遍, 导致加载特慢 解决? 第一个问题, 后续不再使用 html 拼接的形式, 而是将模板写到一个 view.html 中 增加按需加载组件, 而不是上来就把 directives 全定义一遍 将弹窗改写为共用的容器 引入 gulp 对代码进行压缩混淆, 但是 angular 的依赖注入有很多坑, 需要特殊的插件处理 结果经过一番折腾后, 性能稍微有些提升, 但是总体还是不理想最后的解决方法是重构既然要重构, 干脆直接抛弃了 angular 1, 转而投向了 vue 全家桶 通信方式 $emit() , $broadcast() angular.element().scope() $parent , $childHead 公用 service","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"https://laputaz.github.io/home/tags/angular/"},{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"}]},{"title":"对CommonJS,AMD,CMD规范以及script标签异步加载的理解","slug":"js-cmd-amd-common","date":"2018-06-22T15:34:51.000Z","updated":"2021-06-14T08:28:52.071Z","comments":true,"path":"2018/06/22/js-cmd-amd-common/","link":"","permalink":"https://laputaz.github.io/home/2018/06/22/js-cmd-amd-common/","excerpt":"对 CommonJS,AMD,CMD 规范以及 script 标签异步加载的理解","text":"对 CommonJS,AMD,CMD 规范以及 script 标签异步加载的理解 1.牢骚CommonJS, AMD, CMD , 其实很早就接触过了。当时, 网上的文章看得眼花缭乱, 只依稀记得几个模糊的概念。什么依赖前置 , 什么按需加载。一头雾水。 现在再回过头来看看概念 , 网上部分文章用词模棱两可。给我们这些菜鸡, 带来了理解的偏差和困惑。记得第一个项目还用了 requireJS 。时过境迁，现在入门前端 , 都是直接上 webpack 了 。但我觉得还是有必要理一理 。 2. 是什么CommonJS, AMD, CMD 是规范, 理念 ; 对 CommonJS 的实现 , 有 node 的模块系统 ; 对 AMD 的实现有 require.js ; 而 CMD, 是在 sea.js 的实现中提出来的 (但是在Google和Stack Overflow, 这个概念很少被提到, 一般出现在国内)。 CommonJS 规范， 模块加载是同步的对node来说，模块存放在本地硬盘，同步加载，等待时间就是硬盘的读取时间，这个时间非常短; AMD、CMD 规范，模块加载是异步的目的, 是为了适应浏览器环境，加载的时间取决于网络的好坏，可能要等很长时间; 3. 先说 async 和 defer记得看文章的时候, 看到了下面这段话 ,我看了半天, 总觉得不是很理解 , 为什么呢 ?这里说, 脚本标签天生是异步的 , 那为什么会出现 async 和 defer ?然后, 我发觉我并没有把 加载和执行的概念区分清楚 , 这里的加载我把它理解为浏览器中的下载这里贴一张图就很清楚了: &lt;script&gt; 标签, 在下载和执行的时候 , 会阻塞 dom 的渲染进程 , 所以如果把&lt;script&gt; 标签放在&lt;head&gt;中, 当 js 文件很大或者网络差时, 会导致页面长时间空白( 顺带提一下, &lt;script&gt;标签并不会阻止其他的&lt;script&gt;标签的下载, 现代浏览器中多个&lt;script&gt;下载是并行的, 在chrome中, 默认支持6个资源(http1.x)并行下载 ), 另外 , 脚本是按照&lt;script&gt;标签的书写顺序执行的 ; &lt;script defer&gt; 在加上defer以后, 下载的过程就不会阻塞 dom 渲染了, 但脚本的执行是在 dom 渲染完毕之后; &lt;script async&gt;在加上async以后, 下载的过程同样不会阻塞 dom 渲染, 但脚本会在下载完后立刻执行, 所以存在多个&lt;script async&gt;时, 无法保证多个 js 文件的执行顺序, 加载较快的脚本会执行; 所以 defer, async 主要作用于加载阶段, 执行阶段仍然会阻塞 dom 渲染 4. 再看 require.js 的异步体现再看看使用 require.js 的模块写法新建 main.js / a.js / b.js , main.js 为入口, 引用了 a.js , b.js 123456789101112131415161718192021222324// main.js// waitSeconds = 0的配置, 是为了防止文件过大或网络不佳时, 加载时间过长导致require报`Load timeout for modules`的错误require.config(&#123; waitSeconds: 0&#125;);require([\"a.js\", \"b.js\"], function(a, b) &#123; // handle / use a, b console.log(a); console.log(b);&#125;);// a.js ------------------------------define([], function() &#123; return &#123; a: 111111111111 &#125;;&#125;);// b.js ------------------------------define([], function() &#123; return &#123; b: 222222222222 &#125;;&#125;); 文件 开始下载 的 顺序： main, a, b为什么文件下载的顺序是 main, a, b 呢? main依赖了 a b, 不是 a b 先下载吗? 那是因为，只有 main 加载之后，才知道mian依赖了啥啊 执行的 顺序 : a, b, main 或者 b, a, main这里体现 require.js 的异步加载。 a 和 b 的加载或者说下载是并行的, 但 a 和 b 的执行顺序不确定的 , a 和 b 先执行哪一个都无所谓 ,只需要保证回调函数在 a 和 b 都执行完之后再执行就可以了; 在 require.js 中模块加载是怎么实现的呢?看一下 require.js 的源码: 123456789101112/** * Creates the node for the load command. Only used in browser envs. */req.createNode = function(config, moduleName, url) &#123; var node = config.xhtml ? document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"html:script\") : document.createElement(\"script\"); node.type = config.scriptType || \"text/javascript\"; node.charset = \"utf-8\"; node.async = true; return node;&#125;; 这段代码, 新建了 script 标签, 并把它的 async设置为true , 另外, 前面说 , 依赖的模块都执行完之后, 才会执行回调函数。 那怎么判断是否 所有依赖的模块 都已经执行完 ?多个模块的情况 , 还没看懂(捂脸) , 但是单个模块的执行状态是可以监听的: 12345678910111213141516......... //mentioned above about not doing the 'script execute, //then fire the script load event listener before execute //next script' that other browsers do. //Best hope: IE10 fixes the issues, //and then destroys all installs of IE 6-9. //node.attachEvent('onerror', context.onScriptError); &#125; else &#123; node.addEventListener('load', context.onScriptLoad, false); node.addEventListener('error', context.onScriptError, false); &#125; node.src = url; ... ... 上面的代码可以看到, 通过 &lt;script&gt;标签的 onload 事件可以判断, 该脚本是否执行完毕 ; 所以, 个人理解, require.js 的异步第一, 是指下载的异步,第二, 还指回调机制, 依赖模块执行完之后再执行回调函数 5. AMD 和 CMD 的理解误区现在 再来看 AMD 和 CMD 的区别, 网上的说法: AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require 第二点 只有在用到某个模块的时候再去require, 这种说其实是带有误导性的,看看 sea.js 的写法: 1234567define(function(require, exports, module) &#123; console.log(123); var a = require(\"a.js\"); console.log(a); var b = require(\"b.js\"); console.log(b);&#125;); 这里, 难道是执行到require, 才去加载/下载require的文件吗 ?当然不是 ! 看一下 sea.js 的代码: 12345window.define = function(callback) &#123; var id = getCurrentJs() var depsInit = s.parseDependencies(callback.toString()) var a = depsInit.map(item =&gt; basepath + item) .... sea.js 把 callback 回调函数用转换成字符串, 再找出有哪些依赖, 这些依赖模块同样是预先加载的 ,不同在于, require.js 会立刻执行依赖模块, 而 sea.js 在遇到 require 语句的时候 , 再执行依赖模块; 5. 总结AMD 和 CMD 最大的区别是: 对依赖模块的执行时机处理不同(注意不是加载的时机)很多人说, requireJS 是异步加载模块，SeaJS 是同步加载模块，这么说实际上是不准确的 ;二者加载模块都是异步的 ;只不过 AMD 依赖前置，可以方便知道依赖了哪些模块，然后马上加载 , 在加载完成后, 就会执行该模块;而 CMD 推崇就近依赖，把模块变为字符串解析一遍, 找到依赖了哪些模块, 在加载模块完成后, 不立刻执行, 而是等到require后再执行;上面只说了异步相关的概念, 其实 require.js / sea.js , 最重要的还是模块化。模块化降低耦合，依赖清晰，让调试, 加功能, 任务分配和交接都更方便。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"}]}]}